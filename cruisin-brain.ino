////////////////////////////////////////////////////////////////////////
// DO NOT EDIT THIS FILE
////////////////////////////////////////////////////////////////////////

// Required files
#include "settings.h"
#include "config.h"
//"pins.h" -> included in settings.h


void setup() {

  // Setup motor controllers
  setupMotorControllers();
  
  // Stop motor(s)
  sendThrottleCommand(throttleBrake);

  // Setup boards
  setupBoards();
  
  // Setup other peripherals
  setupPeripherals();

  // Setup any pins required
  setupPins();
  
}

void loop() {

  // Timing variables
  static unsigned long currentMicros;
  static unsigned long prev_currentMicros; // Used for loop timing

  currentMicros = micros();

  // Variables to control timing of functions and updates to other variables (always in Microseconds)
  static unsigned long manualControlDebounceInterval = (1000000 / debounceSampleFrequencyHz);
  static unsigned long prev_manualControlDebounceInterval;
  static unsigned long cruiseControlThrottleChangeInterval = 400000; // Micros between cruise control throttle changes
  static unsigned long prev_cruiseControlThrottleChangeInterval;
  static unsigned long oledSerialInterval = 200000; // Micros between sending data to OLED
  static unsigned long prev_oledSerialInterval;
  static unsigned long brakeLightInterval = 100000; // Micros between checking brake light status
  static unsigned long prev_brakeLightInterval;
  static unsigned long headLightInterval = 100000; // Micros between checking headlight status
  static unsigned long prev_headLightInterval;
  static unsigned long indicatorLightInterval = 100000; // Micros between checking indicator status
  static unsigned long prev_indicatorLightInterval;
  static unsigned long currentThrottlePercentInterval = 100000; // Micros between currentThrottlePercent calculations
  static unsigned long prev_currentThrottlePercentInterval;
  static unsigned long batteryInterval = 1000000; // Micros between battery calculations
  static unsigned long prev_batteryInterval;
  static unsigned long debugPrintInterval = 100000; // Micros between debug prints
  static unsigned long prev_debugPrintInterval;
  static unsigned long cruiseControlStatusChangeInterval = 500000; // Micros between cruise control status changes
  static unsigned long prev_cruiseControlStatusChangeInterval;

  // Ramping intervals
  static unsigned long forwardRampInterval;
  static unsigned long prev_forwardRampInterval = 0; // the last time Forward throttle was updated
  static unsigned long reverseRampInterval;
  static unsigned long prev_reverseRampInterval = 0; // the last time Reverse throttle was updated
  static unsigned long brakeRampInterval;
  static unsigned long prev_brakeRampInterval = 0; // will store last time Brake throttle was updated
  static unsigned long cruiseControlRampInterval;
  static unsigned long prev_cruiseControlRampInterval = 0; // the last time Cruise Control throttle was updated

  // System Variables
  static boolean driveInhibited; // Set by inhibit pin
  static boolean startup = true; // Used for startup screen on OLED

  // Manual Input validation variables
  static boolean userSettingsValidated = false; // Variables only need to be calculated when settings are changed
  static boolean forwardError = true; // default error
  static boolean reverseError = true; // default error
  static boolean cruiseControlError = true; // default error

  // Motion Variables
  static boolean onDemandVarsCalced = false; // Only need to be calculated when settings are changed
  static int maxForward;
  static int minForward;
  static int maxReverse;
  static int minReverse;
  static int maxCruiseControl;
  static int minCruiseControl; // Throttle must be over this value for Cruise Control to be enabled
  
  //-----------------------------------

  // Throttle variables
  static int targetThrottle = throttleBrake;
  static int currentThrottle = targetThrottle; // Tracks targetThrottle based on ramp intervals and Cruise Control
  static int currentThrottlePercent; // Value used for OLED display
  static int throttleDeadband_min; // calculated using throttleDeadband_min_Percent
  static int throttleDeadband_max; // calculated using throttleDeadband_max_Percent
  static int driverDeadbandHalf; // calculated using driverDeadband (specific for each driver)

  static int throttleInput; // Throttle input value
  static boolean throttleInputDigital; // Digital forward command value -> used for Cruise Control on button
  static int throttleInputDigitalIntegrator; // Used to debounce throttleInputDigital
  static boolean reverseEnableInput; // Digital command value
  static int reverseEnableInputIntegrator; // Used to debounce reverseEnableCommand
  static boolean cruiseControlInput; // Digital command value
  static int cruiseControlInputIntegrator; // Used to debounce cruiseControlCommand
  static boolean brakeInput; // Analog input value
  static int brakeInputIntegrator; // Used to debounce brakeCommand

  static int forwardCommand; // Forward throttle value after Input Cleanup
  static int reverseCommand; // Reverse throttle value after Input Cleanup
  static boolean brakeCommand; // brake command value after Input Cleanup
  static boolean noMotionCommanded; // Calculated

  static int debounceMax; // Used for debouncing button presses (seconds)

  // Variables for lights
  static boolean indicatorStatus = LOW;
  static boolean indicatorOnL = false;
  static boolean indicatorOnR = false;
  static boolean hazardOn = false;
  static boolean headLightOn = false;
  static boolean brakeLightOn = false;

  // Cruise Control Variables
  static boolean cruiseControlOn = false; // 1 = true, 0 = false
  static unsigned long cruiseControlEnabledMicros = 0; // time that cruiseControl was enabled
  static unsigned long forwardFirstCommandedMicros = 0; // the first time Forward first commanded
  static unsigned long cruiseControl_MC_throttle_EnableDelayMicros = cruiseControl_MC_throttle_EnableDelaySec * 1000000; // convert Seconds to Microseconds
  static unsigned long cruiseControl_MC_throttle_DisableDelayMicros = cruiseControl_MC_throttle_DisableDelaySec * 1000000; // convert Seconds to Milliseconds
  static boolean cruiseControlFirstEnabled = false;

  // Battery Variables
  static int batteryVoltage; // Battery voltage read from pin
  static float batteryPercent; // Calculated battery percent
  static int batteryCurrent; // battery current read from pin
  static float batteryMinVoltage; // calculated minVoltage
  static float batteryMaxVoltage; // calculated maxVoltage


  // Show startup screen TODO -> needs countdown and then change startup to FALSE
  if (startup == true) {
    #if defined(OLED)
      oledSendData(startup, batteryPercent, batteryVoltageWarningPercent, currentThrottlePercent, 
        batteryCurrent, cruiseControlOn, brakeLightOn, headLightOn, indicatorOnL, indicatorOnR,
        hazardOn, forwardError, reverseError, cruiseControlError, driveInhibited,
        currentMicros, prev_oledSerialInterval, oledSerialInterval);
      delay(3000);// Show startup screen for a while
    #endif
    startup = false;
  }

  // Validate User Settings - must be done every loop as User settings can be changed while car is operational
  if (userSettingsValidated == false) {
    validateUserSettings(forwardError, reverseError, cruiseControlError);
    // If there is an Error do not proceed
    while (forwardError == true || reverseError == true || cruiseControlError == true) {
      #if defined(OLED)
        oledSendData(startup, batteryPercent, batteryVoltageWarningPercent, currentThrottlePercent, 
          batteryCurrent, cruiseControlOn, brakeLightOn, headLightOn, indicatorOnL, indicatorOnR,
          hazardOn, forwardError, reverseError, cruiseControlError, driveInhibited,
          currentMicros, prev_oledSerialInterval, oledSerialInterval);
      #endif
      #if defined(DEBUG_ON)
        Serial.println("User Settings Error");
      #endif
    }
    userSettingsValidated = true;
  }

  // Check if drive has been inhibited by switch, charger or panic button
  // Can only be reset by restart of Cruisin Brain
  // Can be overriden by INHIBIT_IGNORE in settings.h
  #if defined(INHIBIT_IGNORE)
    driveInhibited = HIGH;
  #elif
    driveInhibited = digitalRead(inhibit_pin);
  #endif
  
  while (driveInhibited == LOW) {
    sendThrottleCommand(throttleBrake); // Send brake to motorController
    getSetAllLights(currentThrottle, targetThrottle, brakeLightOn, headLightOn, 
        indicatorStatus, indicatorOnL, indicatorOnR, hazardOn,
        brakeLightInterval, prev_brakeLightInterval, 
        headLightInterval, prev_headLightInterval, 
        indicatorLightInterval, prev_indicatorLightInterval,
        currentMicros);
    #if defined(OLED)
      oledSendData(startup, batteryPercent, batteryVoltageWarningPercent, currentThrottlePercent, 
        batteryCurrent, cruiseControlOn, brakeLightOn, headLightOn, indicatorOnL, indicatorOnR,
        hazardOn, forwardError, reverseError, cruiseControlError, driveInhibited,
        currentMicros, prev_oledSerialInterval, oledSerialInterval);
    #endif
    #if defined(DEBUG_ON)
      Serial.println("Drive Inhibited");
    #endif
  }

  // Calculate on demand variables
  if (onDemandVarsCalced == false) {
    calcForwardReverseValues(maxForward, minForward, maxReverse, minReverse);
    calcRampIntervals(forwardRampInterval, reverseRampInterval, brakeRampInterval, cruiseControlRampInterval);
    calcCruiseControlValues(maxCruiseControl, minCruiseControl);
    calcDeadband(throttleDeadband_min, throttleDeadband_max, driverDeadbandHalf);
    calcBatteryMinMax(batteryMinVoltage, batteryMaxVoltage);
    calcDebounceMax(debounceMax);
    onDemandVarsCalced = true;
  }

  #if defined(HTTP)
    httpWebServer();
  #endif

  // Get and Set all lights-> safety feature for night time use
  getSetAllLights(currentThrottle, targetThrottle, brakeLightOn, headLightOn, 
          indicatorStatus, indicatorOnL, indicatorOnR, hazardOn,
          brakeLightInterval, prev_brakeLightInterval, 
          headLightInterval, prev_headLightInterval, 
          indicatorLightInterval, prev_indicatorLightInterval,
          currentMicros);

  // Get Inputs
  if (throttleType == "Normal") {
    getNormalThrottleInput(throttleInput);
  
    getInputsDigital(debounceMax, throttleInputDigital, throttleInputDigitalIntegrator,
          reverseEnableInput, reverseEnableInputIntegrator, brakeInput, brakeInputIntegrator,
          cruiseControlInput, cruiseControlInputIntegrator,
          currentMicros, manualControlDebounceInterval, prev_manualControlDebounceInterval);
  }

  // Cleanup inputs and return modified values
  cleanupInputs(throttleInput, throttleInputDigital, reverseEnableInput, brakeInput, cruiseControlInput,
        forwardCommand, reverseCommand, brakeCommand, noMotionCommanded, 
        cruiseControlOn, throttleDeadband_min, throttleDeadband_max);
  
  // If Cruise Control is enabled by its own button
  if (cruiseControlType == "Button" && (cruiseControlOn == true || cruiseControlInput == true || brakeCommand == true)) {
    cruiseControlButton(currentThrottle, cruiseControlOn, minCruiseControl, cruiseControlFirstEnabled, cruiseControlInput, brakeCommand,
    currentMicros, cruiseControlStatusChangeInterval, prev_cruiseControlStatusChangeInterval);
  }

  // If Cruise Control enabled by Forward
  if (cruiseControlType == "Throttle" && ((currentMicros - prev_cruiseControlStatusChangeInterval) >= cruiseControlStatusChangeInterval)) {
    cruiseControlForwardEnable(targetThrottle, currentThrottle, forwardCommand, reverseCommand, reverseEnableInput,
      noMotionCommanded, brakeCommand, cruiseControlOn,
      cruiseControlEnabledMicros, forwardFirstCommandedMicros, cruiseControl_MC_throttle_EnableDelayMicros, 
      cruiseControl_MC_throttle_DisableDelayMicros, currentMicros);
  }

  // Calculate the Target throttle
  calcTargetThrottle(targetThrottle, currentThrottle, forwardCommand, throttleInputDigital, 
      reverseCommand, reverseEnableInput, noMotionCommanded, brakeCommand, 
      cruiseControlOn, cruiseControlFirstEnabled,
      maxForward, minForward, maxReverse, minReverse, maxCruiseControl,
      currentMicros, cruiseControlThrottleChangeInterval, prev_cruiseControlThrottleChangeInterval);

  // Calculate motion on all inputs and settings
  calcMotion(targetThrottle, forwardCommand, reverseCommand, noMotionCommanded, brakeCommand,
      cruiseControlOn, currentThrottle,
      maxForward, prev_forwardRampInterval, forwardRampInterval,
      maxReverse, prev_reverseRampInterval, reverseRampInterval,
      maxCruiseControl, prev_cruiseControlRampInterval, cruiseControlRampInterval, forwardFirstCommandedMicros,
      throttleBrake, prev_brakeRampInterval, brakeRampInterval,
      driverDeadbandHalf, currentMicros);

  // Check Battery Details
  if ((currentMicros - prev_batteryInterval) >= batteryInterval) {
    getBatteryDetails(batteryVoltage, batteryPercent, batteryMinVoltage, batteryMaxVoltage);
    prev_batteryInterval = currentMicros;
  }

  // Calculate currentThrottlePercent
  #if defined(OLED) || defined(DEBUG_ON) // Only used for these things
    if ((currentMicros - prev_currentThrottlePercentInterval) >= currentThrottlePercentInterval) {
      calcCurrentThrottlePercent(currentThrottle, currentThrottlePercent, throttleBrake, minForward, maxForward);
      prev_currentThrottlePercentInterval = currentMicros;
    }
  #endif

  // Send information via serial to microcontroller running OLED
  #if defined(OLED)
    oledSendData(startup, batteryPercent, batteryVoltageWarningPercent, currentThrottlePercent, 
      batteryCurrent, cruiseControlOn, brakeLightOn, headLightOn, indicatorOnL, indicatorOnR,
      hazardOn, forwardError, reverseError, cruiseControlError, driveInhibited,
      currentMicros, prev_oledSerialInterval, oledSerialInterval);
  #endif

  // Main loop complete, except debug
    prev_currentMicros = currentMicros;

  #if defined(DEBUG_ON)
    if ((currentMicros - prev_debugPrintInterval) >= debugPrintInterval) {
      // Get the value early or it slows down
      long looptime = currentMicros - prev_currentMicros;
      
      if (cruiseControlType == "Throttle") {
        if (forwardFirstCommandedMicros > 0 && cruiseControlOn == false) {
          Serial.print("CC in: ");Serial.print(cruiseControl_MC_throttle_EnableDelayMicros - (currentMicros - forwardFirstCommandedMicros));Serial.print(" ");
        } else if (cruiseControlOn == true) {
          Serial.print("CC ON ");Serial.print(" ");
        } else {
          Serial.print("CC in: ");Serial.print(cruiseControl_MC_throttle_EnableDelayMicros);Serial.print(" ");
        }
        Serial.print("CCO : ");Serial.print(cruiseControlOn);Serial.print(" ");
        Serial.print("FFCM : ");Serial.print(forwardFirstCommandedMicros);Serial.print(" || ");
      } else {
        Serial.print("CCO : ");Serial.print(cruiseControlOn);Serial.print(" || ");
      }
      
      Serial.print("F: ");Serial.print(forwardCommand);Serial.print(" ");
      Serial.print("FD: ");Serial.print(throttleInputDigital);Serial.print(" ");
      Serial.print("R: ");Serial.print(reverseCommand);Serial.print(" ");
      Serial.print("RE: ");Serial.print(reverseEnableInput);Serial.print(" ");
      Serial.print("NI: ");Serial.print(noMotionCommanded);Serial.print(" ");
      Serial.print("B: ");Serial.print(brakeCommand);Serial.print(" ");
      Serial.print("CC : ");Serial.print(cruiseControlInput);Serial.print(" || ");
      Serial.print("Tar: ");Serial.print(targetThrottle);Serial.print(" ");
      Serial.print("Cur: ");Serial.print(currentThrottle);Serial.print(" ");
      Serial.print("CurP: ");Serial.print(currentThrottlePercent);
      Serial.print(" || ");
      
//      Serial.print("FRI: ");Serial.print(forwardRampInterval);Serial.print(" ");
//      Serial.print("RRI: ");Serial.print(reverseRampInterval);Serial.print(" ");
//      Serial.print("CCRI: ");Serial.print(cruiseControlRampInterval);Serial.print(" ");
//      Serial.print("BRI: ");Serial.print(brakeRampInterval);
//      Serial.print(" || ");
      
      Serial.print("TDB: ");Serial.print(throttleDeadband_min);Serial.print(" ");
      Serial.print("DDB: ");Serial.print(driverDeadband);
      Serial.print(" || ");
      
      Serial.print("LT: ");Serial.print(looptime);Serial.print(" ");
      
      Serial.println();
      prev_debugPrintInterval = currentMicros;
    }
  #endif

} // end of main loop

// If Cruise Control is enabled by button
void cruiseControlButton(int currentThrottle, boolean &cruiseControlOn, int minCruiseControl, boolean &cruiseControlFirstEnabled, boolean cruiseControlCommand,
        boolean brakeCommand, unsigned long currentMicros, unsigned int cruiseControlStatusChangeInterval, unsigned long &prev_cruiseControlStatusChangeInterval) {

    //If Cruise Control is ON
    if (cruiseControlOn == true) {
      // Disable IF -> Can disable at any time with brakeCommand
      if (brakeCommand == true) {
          cruiseControlOn = false;
          prev_cruiseControlStatusChangeInterval = currentMicros; // reset
      }
      // Restrict changing from on to off too quickly
      else if ((currentMicros - prev_cruiseControlStatusChangeInterval) >= cruiseControlStatusChangeInterval) {
        if (cruiseControlCommand == true) {
            cruiseControlOn = false;
            prev_cruiseControlStatusChangeInterval = currentMicros; // reset
        }
        // Disable if
        else if (currentThrottle < minCruiseControl && reverseMotorDirection == false) {
            cruiseControlOn = false;
            prev_cruiseControlStatusChangeInterval = currentMicros; // reset
        }
        // Disable if
        else if (currentThrottle > minCruiseControl && reverseMotorDirection == true) {
            cruiseControlOn = false;
            prev_cruiseControlStatusChangeInterval = currentMicros; // reset
        }
      }
    }
    // If Cruise Control is OFF
    else if (cruiseControlOn == false) {
      // If CruiseControl button pushed
      if (cruiseControlCommand == true && ((currentMicros - prev_cruiseControlStatusChangeInterval) >= cruiseControlStatusChangeInterval)) {
        // Enable if
        if (currentThrottle > minCruiseControl && reverseMotorDirection == false) {
            cruiseControlOn = true;
            cruiseControlFirstEnabled = true;
            prev_cruiseControlStatusChangeInterval = currentMicros;
        }
        // Enable if
        else if (currentThrottle < minCruiseControl && reverseMotorDirection == true) {
            cruiseControlOn = true;
            cruiseControlFirstEnabled = true;
            prev_cruiseControlStatusChangeInterval = currentMicros;
        }
    }
  }
}

// Cruise Control enabled by Forward
void cruiseControlForwardEnable(int targetThrottle, int currentThrottle, int forwardCommand, int reverseCommand, boolean reverseEnableCommand, 
          boolean noMotionCommanded, boolean brakeCommand, boolean &cruiseControlOn,
          unsigned long &cruiseControlEnabledMicros, unsigned long &forwardFirstCommandedMicros, unsigned int cruiseControl_MC_forward_EnableDelayMicros, 
          unsigned int cruiseControl_MC_forward_DisableDelayMicros, unsigned long currentMicros) {

    // Check that targetThrottle is positive and forwardCommand > 0
    // targetThrottle can be negative when reverseMotorDirection = true
    if (abs(targetThrottle) > 0 && forwardCommand > 0) {
      // Only set forwardFirstCommandedMicros the first time forwardCommand > 0
      if (forwardFirstCommandedMicros == 0) {
          forwardFirstCommandedMicros = currentMicros;
      }
       // Is forwardFirstCommandedMicros >= cruiseControlWaitMicros
      else if (forwardFirstCommandedMicros > 0 && cruiseControlOn == false && (currentMicros - forwardFirstCommandedMicros >= cruiseControl_MC_forward_EnableDelayMicros)) {
        cruiseControlOn = true; // Enabled Cruise Control
        cruiseControlEnabledMicros = currentMicros; // Set the time when Cruise Control was enabled
      }
      // Disable Cruise Control if cruiseControlOn, Forward commanded (see above) and cruiseControl_MC_forward_DisableDelayMicros has elapsed
      else if (cruiseControlOn == true && (currentMicros - cruiseControlEnabledMicros) >= cruiseControl_MC_forward_DisableDelayMicros) {
        cruiseControlOn = false; // Disable Cruise Control
        forwardFirstCommandedMicros = 0; // Reset to zero
        cruiseControlEnabledMicros = 0; // Reset to zero
      }
    }
    // Disable Cruise Control when Brake or Reverse is commanded
    else if (cruiseControlOn == true && (brakeCommand == true || reverseCommand > 0 || reverseEnableCommand == true)) {
      cruiseControlOn = false; // Disable Cruise Control
      forwardFirstCommandedMicros = 0; // Reset to zero
      cruiseControlEnabledMicros = 0; // Reset to zero
    }
    else if (targetThrottle == throttleBrake || reverseCommand > 0 || brakeCommand == true || reverseEnableCommand == true) {
      cruiseControlOn = false; // Disable Cruise Control
      forwardFirstCommandedMicros = 0; // Reset to zero
    }

}

// Calculate the target throttle -> the throttle value we are aiming for as opposed to the current throttle
void calcTargetThrottle(int &targetThrottle, int currentThrottle, int forwardCommand, boolean throttleInputDigital, 
      int reverseCommand, boolean reverseEnableCommand, boolean noMotionCommanded, boolean brakeCommand, 
      boolean cruiseControlOn, boolean &cruiseControlFirstEnabled,
      int maxForward, int minForward, int maxReverse, int minReverse, int maxCruiseControl,
      unsigned long currentMicros, unsigned int cruiseControlThrottleChangeInterval, unsigned long &prev_cruiseControlThrottleChangeInterval) {

  // If cruise control is on
  if (cruiseControlOn == true) {
    // If Cruise Control is enabled by Throttle
    if (cruiseControlType == "Throttle") {
      targetThrottle = maxCruiseControl;
    }
    // If Cruise Control enabled by button
    else if (cruiseControlType == "Button") {
      // First time Cruise Control enabled
      if (cruiseControlFirstEnabled == true) {
        targetThrottle = currentThrottle;
        // Make sure targetThrottle is never higher than maxCruiseControl
        if (targetThrottle > maxCruiseControl && reverseMotorDirection == false) {
          targetThrottle = maxCruiseControl;
        }
        // Make sure targetThrottle is never higher than maxCruiseControl
        else if (targetThrottle < maxCruiseControl && reverseMotorDirection == true) {
          targetThrottle = maxCruiseControl;
        }
        cruiseControlFirstEnabled = false;
      }
      else if (throttleInputDigital == true && reverseMotorDirection == false) {
        if ((currentMicros - prev_cruiseControlThrottleChangeInterval) >= cruiseControlThrottleChangeInterval) {
          targetThrottle++;
          prev_cruiseControlThrottleChangeInterval = currentMicros;
        }
        // Limit targetThrottle to maxCruiseControl
        if (targetThrottle > maxCruiseControl) {
          targetThrottle = maxCruiseControl;
        }
      }
      else if (throttleInputDigital == true && reverseMotorDirection == true) {
        if ((currentMicros - prev_cruiseControlThrottleChangeInterval) >= cruiseControlThrottleChangeInterval) {
          targetThrottle--;
          prev_cruiseControlThrottleChangeInterval = currentMicros;
        }
        // Limit targetThrottle to maxCruiseControl
        if (targetThrottle < maxCruiseControl) {
          targetThrottle = maxCruiseControl;
        }
      }
      else if (reverseEnableCommand == true && reverseMotorDirection == false) {
        if ((currentMicros - prev_cruiseControlThrottleChangeInterval) >= cruiseControlThrottleChangeInterval) {
          targetThrottle--;
          prev_cruiseControlThrottleChangeInterval = currentMicros;
        }
      }
      else if (reverseEnableCommand == true && reverseMotorDirection == true) {
        if ((currentMicros - prev_cruiseControlThrottleChangeInterval) >= cruiseControlThrottleChangeInterval) {
          targetThrottle++;
          prev_cruiseControlThrottleChangeInterval = currentMicros;
        }
      }
    }
  }
  // If forward commanded
  else if (forwardCommand > 0 && cruiseControlOn == false) {
    targetThrottle = mapfloat(forwardCommand, 0, 1023, minForward, maxForward);
  } 
  // If reverse commanded
  else if (reverseCommand > 0 && cruiseControlOn == false) {
    targetThrottle = mapfloat(reverseCommand, 0, 1023, minReverse, maxReverse);
  }
  // If no motion commanded
  else if (noMotionCommanded == true) {
    targetThrottle = throttleBrake;
  }
  // If brake commanded
  else if (brakeCommand == true) {
    targetThrottle = throttleBrake;
  }
}

// Calculate motion based on inputs/outputs and other states
void calcMotion(int targetThrottle, int forwardCommand, int reverseCommand, boolean noMotionCommanded, boolean brakeCommand,
      boolean cruiseControlOn, int &currentThrottle,
      int maxForward, unsigned long &prev_forwardRampMicros, unsigned int forwardRampInterval,
      int maxReverse, unsigned long &prevReverseRampMicros, unsigned int reverseRampInterval,
      int maxCruiseControl, unsigned long &prev_cruiseControlRampMicros, unsigned int cruiseControlRampInterval, unsigned long &forwardFirstCommandedMicros,
      int throttleBrake, unsigned long &prevBrakeRampMicros, unsigned int brakeRampInterval,
      int driverDeadbandHalf, unsigned long currentMicros) {

    // Forward
    if (forwardCommand > 0 && cruiseControlOn == false) {
      if (currentThrottle > targetThrottle) {
          reduceThrottle(prev_forwardRampMicros, forwardRampInterval, currentThrottle, targetThrottle, driverDeadbandHalf, currentMicros);
      }
      else if (currentThrottle < targetThrottle) {
          increaseThrottle(prev_forwardRampMicros, forwardRampInterval, currentThrottle, targetThrottle, driverDeadbandHalf, currentMicros);
      }
      else if (currentThrottle == targetThrottle) {
          sendThrottleCommand(currentThrottle);
      }
    }
    // Reverse
    else if (reverseCommand > 0 && cruiseControlOn == false) {
      if (currentThrottle > targetThrottle) {
          reduceThrottle(prevReverseRampMicros, reverseRampInterval, currentThrottle, targetThrottle, driverDeadbandHalf, currentMicros);
      }
      else if (currentThrottle < targetThrottle) {
          increaseThrottle(prevReverseRampMicros, reverseRampInterval, currentThrottle, targetThrottle, driverDeadbandHalf, currentMicros);
      }
      else if (currentThrottle == targetThrottle) {
          sendThrottleCommand(currentThrottle);
      }
    }
    // Cruise Control
    else if (cruiseControlOn == true) {
      if (currentThrottle > targetThrottle) {
          reduceThrottle(prev_cruiseControlRampMicros, cruiseControlRampInterval, currentThrottle, targetThrottle, driverDeadbandHalf, currentMicros);
      }
      else if (currentThrottle < targetThrottle) {
          increaseThrottle(prev_cruiseControlRampMicros, cruiseControlRampInterval, currentThrottle, targetThrottle, driverDeadbandHalf, currentMicros);
      }
      else if (currentThrottle == targetThrottle) {
          sendThrottleCommand(currentThrottle);
      }
    }
    // Brake
    else if (noMotionCommanded == true || brakeCommand == true)  {
        if (currentThrottle > targetThrottle) {
            reduceThrottle(prevBrakeRampMicros, brakeRampInterval, currentThrottle, targetThrottle, driverDeadbandHalf, currentMicros);
        }
        else if (currentThrottle < targetThrottle) {
            increaseThrottle(prevBrakeRampMicros, brakeRampInterval, currentThrottle, targetThrottle, driverDeadbandHalf, currentMicros);
        }
        else if (currentThrottle == targetThrottle) {
            sendThrottleCommand(targetThrottle);
        }
    }
  
}

// Increase throttle
void increaseThrottle(unsigned long &prevMicros, unsigned int intervalMicros, int &currentThrottle, int targetThrottle, int driverDeadbandHalf, unsigned long currentMicros) {

  if (currentMicros - prevMicros >= intervalMicros) {
    // Remove Driver deadband if driverDeadband is set
    if (currentThrottle > (throttleBrake - driverDeadbandHalf) && currentThrottle < (throttleBrake + driverDeadbandHalf) && targetThrottle > throttleBrake) {
        currentThrottle = (throttleBrake + driverDeadbandHalf);
    }
    // Increase currentThrottle by 1
    for (;currentThrottle <= targetThrottle;) {
      currentThrottle++;
      prevMicros = currentMicros;
      break;
      }
  }
  // Send throttle command even if there is no update -> in essence a keepalive for the motor controller which are usually programmed to stop if no update sent
  sendThrottleCommand(currentThrottle);
}

// Reduce throttle
void reduceThrottle(unsigned long &prevMicros, unsigned int intervalMicros, int &currentThrottle, int targetThrottle, int driverDeadbandHalf, unsigned long currentMicros) {

  if (currentMicros - prevMicros >= intervalMicros) {
    // Remove Driver deadband if driverDeadband is set
    if (currentThrottle > (throttleBrake - driverDeadbandHalf) && currentThrottle < (throttleBrake + driverDeadbandHalf) && targetThrottle < throttleBrake) {
        currentThrottle = (throttleBrake - driverDeadbandHalf);
    }
    // Reduce currentThrottle by 1
    for (;currentThrottle >= targetThrottle;) {
      currentThrottle--;
      prevMicros = currentMicros;
      break;
      }
  }
  // Send throttle command even if there is no update -> in essence a keepalive for the motor controller which are usually programmed to stop if no update sent
  sendThrottleCommand(currentThrottle);

}

// Send currentThrottle to the motor controller
void sendThrottleCommand(int currentThrottle) {

#if defined(MOT_SYREN50)
  MOT_SYREN50_sendThrottle(currentThrottle);
#endif

#if defined(MOT_SABER2x32)
  MOT_SABER2x32_sendThrottle(currentThrottle);
#endif

#if defined(MOT_SPARK)
  MOT_SPARK_sendThrottle(currentThrottle);
#endif

}
